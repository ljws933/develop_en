var tipuesearch = {"pages": [{
    "title": "what is Android MVVM architecture and why it is needed?",
    "text": "Android MVVM Architecture Comparison of MVC vs MVP vs MVVM The reason for the emergence and necessity of MVVM Method of implementing MVVM MVC: Activity and Fragment are responsible for View and Controller In the MVC pattern, the View and Controller are connected as shown below. In other words, the Controller is implemented in the Activity or Fragment. When using this architecture, the following problems can arise: If the lifecycle of the Activity changes, it affects the View or Controller implemented inside the Activity. As the scale increases, there are many cases where you have to change multiple parts when changing one place. If you modify the View, you have to modify the Controller as well. If you modify the Controller, you have to modify the Model as well. To solve these problems, an architecture that pursues loose coupling has emerged. MVP MVVM MVP: The appearance of Presenter that loosely couples with View In the MVP architecture, unlike the MVC pattern where the Controller is defined in the View, Presenter is introduced and takes over the role of the Controller. In other words, it is as follows: View handles the user interface, and Model handles the data. However, the MVP pattern also causes the following problems: As the role of the Presenter grows, the Presenter class becomes complex. As a result, the maintenance of the Presenter becomes difficult. The MVP pattern is difficult to manage the state change between View and Model. If you change the state of the Model according to the event that occurs in the View, you need to handle a lot of work in the Presenter to reflect it in the View. To solve this, the MVVM pattern emerged. MVVM: The emergence of ViewModel that observes the state of View With the emergence of ViewModel, which can know the state of View, complete separation between View and ViewModel became possible. Therefore, ViewModel does not perform UI-related work in the MVVM architecture. ViewModel only updates data, and View only shows the data. This provides the following benefits: Reactive programming is possible through state observation. The amount of code written has been greatly reduced and UI can be easily changed through viewBinding and dataBinding introduced in ViewModel. Complete independence between View and ViewModel is achieved. This makes testing easier. Reactive programming is possible through state observation In the MVVM architecture, the View subscribes to the Publisher that recognizes the lifecycle, called LiveData, in Activity and Fragment. As a result, the View performs a behavior that reacts to changes when the data changes. This allows users to change the data whenever they enter a specific input and display or internally process the changed data on the UI. Significant reduction in code and easy UI changes through viewBinding and dataBinding In general, there are projects that use both viewBinding and dataBinding in one project, and projects that use only one. However, you should know their characteristics well, and their characteristics are as follows. Characteristics of viewBinding Generates a binding class that maps to the XML file at compile time The binding class can reference the View Faster performance than the findViewById() method Only analyzes the XML layout file when the binding class is created, so unnecessary XML file analysis does not occur at runtime Excellent build time performance and memory efficiency Characteristics of dataBinding Performs data binding between View and XML file at runtime Provides a function that updates the UI by writing expressions directly in the XML file Can easily handle UI-related tasks Slower performance than the findViewById() method Performance degradation may occur as the complexity of data binding increases Optimization of memory usage is possible One of the biggest differences between the web and mobile is that mobile has a limit on the resources that can be used. Therefore, you should always think about memory optimization and remove unused elements as much as possible to make them available elsewhere. If you use the MVVM pattern, you can observe the state of the View and delete it when it is not in use. However, data is not deleted immediately when the View dies, because it costs money to recreate the data when the View is called again. Therefore, as shown in the figure below, the data remains in the viewMocelScope for a certain period of time even if the View dies.",
    "tags": "android",
    "url": "/android/2023/03/17/android-mvvm-1/"
  },{
    "title": "Android Kotlin Braodcast Receiver test - for beginner",
    "text": "Testing Android Broadcast Receiver There are two ways to test a Broadcast Receiver: Sending a signal directly to the Broadcast Receiver using ADB. Using Instrumented Unit Test to test on an emulator. Let’s take a look at how to use them and their pros and cons. Testing Android Broadcast Receiver using ADB First, to test it using ADB, you need to create a test environment as follows: Connect your Android device to your computer. Verify that the device is connected using ADB. Enter the command “adb devices” and check if the connected device is displayed. Open the ADB shell to send a broadcast event. Enter the command “adb shell”. Send a broadcast event. Use the “am broadcast” command to generate a broadcast intent. For example, enter “am broadcast -a android.intent.action.BOOT_COMPLETED” to simulate a boot completed event. Verify that the event has been received. You can verify that the broadcast has been sent by running an app that checks for broadcast reception. For example, to check for a boot completed event, restart your device, log in, and run the app to verify the event. Modifying AndroidManifest You need to register the in AndroidManifest as follows: Set exported to true so that you can receive broadcasts from outside. &lt;receiver android:name=\".mybroadcast.MyReceiver\" android:exported=\"true\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.BOOT_COMPLETED\" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; Notes System commands such as android.intent.action.BOOT_COMPLETED cannot be called from outside on Android 26 (Oreo) or later. Therefore, you can only test it with a custom action or by specifying a package and class name, as shown below. adb shell am broadcast -n your.package.name/your.package.name.braodcastClassName -e ACTION_BUTTON \"action1\" Note: n is the package name/broadcast class name. e is the data to be sent together. (For example, here, “action1” is included in the name ACTION_BUTTON.) Testing with AndroidJUnit4 Create a file in the androidTest package and enter the following to easily test it. import android.content.Context import android.content.Intent import androidx.test.core.app.ApplicationProvider import androidx.test.ext.junit.runners.AndroidJUnit4 import androidx.test.platform.app.InstrumentationRegistry import org.junit.Assert.assertEquals import org.junit.Test import org.junit.runner.RunWith @RunWith(AndroidJUnit4::class) class MyBroadcastReceiverInstrumentedTest { @Test fun testOnReceive() { val context = InstrumentationRegistry.getInstrumentation().context val intent = Intent(\"android.intent.action.BOOT_COMPLETED\") val receiver = MyBroadcastReceiver() receiver.onReceive(context, intent) // Add verification code assertEquals(\"android.intent.action.BOOT_COMPLETED\", intent.action) } } You can test “android.intent.action.BOOT_COMPLETED” with AndroidJUnit4.",
    "tags": "android",
    "url": "/android/2023/03/16/broadcast-test/"
  },{
    "title": "What is annotation in kotlin? custom annotation, built in annotation - 2",
    "text": "Summary of frequently used annotations in Kotlin-2 In this post, we will learn how to customize annotations following the previous post. Summary of frequently used annotations in Kotlin-1 Learn about frequently used annotations in Kotlin Annotations are a means of adding metadata (additional features) to code non-intrusively. Kotlin has various types of annotations. Kotlin에 대한 자주 사 android-developer.tistory.com Custom Annotation using Reflection There are two ways to customize annotations in Kotlin: Using Reflection Using Code Generation First, let’s briefly explain what Reflection is. Reflection is a technique that analyzes the structure of a program (objects, functions, properties) at runtime. In other words, when the program is running, you can determine the internal structure of an object through instances, etc. However, since it is necessary to check it every time, it can cause performance degradation of the app. To use Reflection in Kotlin, you need to use KClass. You can find information about Kotlin Reflection here. Android Kotlin Reflection Basic Definition In Kotlin, Reflection is a technique used to examine the classes of programs at runtime. In other words, you can understand the internal structure of an object through instances, etc., while the program is running. 대 android-developer.tistory.com To use KClass in Kotlin, you need to add the following library: implementation \"org.jetbrains.kotlin:kotlin-reflect:$kotlin_version\" Then, let’s create an annotation class by specifying the annotation as follows: @Target(AnnotationTarget.PROPERTY) annotation class StringConstraint( val minLength: Int, val maxLength: Int ) The StringContraint annotation class created above is an annotation class created to define the minimum and maximum length of a String variable. Apply this custom annotation to the data class with property values. data class Data( // set field value with custom annotation@StringConstraint(10, 50) val title: String, @StringConstraint(100, 500) val contents: String ) Now, write the code to check the validation using these two. object FieldValidator { data class ValidationResult( var isValid: Boolean = true, val invalidFieldNames: MutableList&lt;String&gt; = mutableListOf() ) fun validate(data: Data): ValidationResult { val result = ValidationResult() // get property information with reflectiondata::class.declaredMemberProperties.forEach { val field = it val annotation = it.findAnnotation&lt;StringConstraint&gt;() if (annotation != null &amp;&amp; field.getter.visibility == KVisibility.PUBLIC) { val fieldValue = field.getter.call(data) as String // set validation with annotation field value if (fieldValue.length !in annotation.minLength..annotation.maxLength) { result.isValid = false result.invalidFieldNames.add(field.name) } } } return result } } Then, write the following code and run it. fun main() { val data = Data( \"transparency to the extreme\", \"Transparency means sharing more than just results. It means sharing enough to know the intent, context, and process. We believe that the extreme honesty we seek can only be achieved when transparency is a prerequisite.\" ) val validationResult = FieldValidator.validate(data) // Validation: false / not validated Field: [title] println(\"Validation: ${validationResult.isValid} / not validated Field: ${validationResult.invalidFieldNames}\") } Summary We have learned how to use custom annotations and Kotlin Reflection. By the way, all the codes are as follows. import kotlin.reflect.KVisibility import kotlin.reflect.full.declaredMemberProperties import kotlin.reflect.full.findAnnotation @Target(AnnotationTarget.PROPERTY) annotation class StringConstraint( val minLength: Int, val maxLength: Int ) data class Data( // set field value with custom annotation@StringConstraint(10, 50) val title: String, @StringConstraint(100, 500) val contents: String ) object FieldValidator { data class ValidationResult( var isValid: Boolean = true, val invalidFieldNames: MutableList&lt;String&gt; = mutableListOf() ) fun validate(data: Data): ValidationResult { val result = ValidationResult() // get property information with reflectiondata::class.declaredMemberProperties.forEach { val field = it val annotation = it.findAnnotation&lt;StringConstraint&gt;() if (annotation != null &amp;&amp; field.getter.visibility == KVisibility.PUBLIC) { val fieldValue = field.getter.call(data) as String // set validation with annotation field value if (fieldValue.length !in annotation.minLength..annotation.maxLength) { result.isValid = false result.invalidFieldNames.add(field.name) } } } return result } } fun main() { val data = Data( \"transparency to the extreme\", \"Transparency means sharing more than just results. It means sharing enough to know the intent, context, and process. We believe that the extreme honesty we seek can only be achieved when transparency is a prerequisite.\" ) val validationResult = FieldValidator.validate(data) // Validation: false / not validated Field: [title] println(\"Validation: ${validationResult.isValid} / not validated Field: ${validationResult.invalidFieldNames}\") } In the next post, we will learn about the second way to customize annotations, which is: Insert logic into annotations using Code Generation at Compile Time",
    "tags": "kotlin",
    "url": "/kotlin/2023/03/11/kotlin-annotation2/"
  },{
    "title": "What is Reflection in kotlin and How to use it. for beginners",
    "text": "What is Reflection in Kotlin? What is Kotlin Reflection? Accessing Reflection Creating Objects with Reflection Executing Functions of Objects Created with Reflection Accessing Variables of Objects Created with Reflection Adding Dependencies (Libraries) for Using Reflection in Kotlin To use Reflection in Kotlin, you need to add the following dependencies: If you are using Android Studio: implementation \"org.jetbrains.kotlin:kotlin-reflect:{kotlin_version}\" If you are using InteliJ IDEA, the library is already included in the IDE, so you don’t need to add it separately. Creating a Custom Annotation Class for Reflection Use Create a class with the annotation to be used in Reflection as follows. (In fact, this part works well without it, but it is an example because annotations use Reflection a lot.) // Create custom annotations. annotation class CustomAnnotation // Class with one main constructor. class MyClass(val first: Int) { // Two member variables of the class. private val immutableSecret: Int = 2 private var mutableSecret: Int = 3 // A function to add two numbers. fun make(second: Int): Int { return first + second } // A private function to add two member variables. private fun secretMake(): Int { return immutableSecret + mutableSecret } } Accessing Reflection The object used to use Reflection in Kotlin is called a reference object. There are two ways to create such a reference object, using an instance or using a class. The following code obtains a KClass by using ::class and accesses the object reference. val myClass = MyClass(5) // KClass is a generic type, so you need to handle inheritance with out. val kClass: KClass&lt;out MyClass&gt; = myClass::class Note that ::class and ::class.java are different. You can also create it as follows without creating an instance object. val kClass: KClass&lt;MyClass&gt; = MyClass::class You can use this KClass type Reflection reference object to check the following information: val myClass = MyClass(5) // KClass is a generic type, so you need to handle inheritance with out. val kClass: KClass&lt;out MyClass&gt; = myClass::class // qualifiedName = MyClass println(\"qualifiedName = ${kClass.qualifiedName}\") // isAbstract = false println(\"isAbstract = ${kClass.isAbstract}\") // isCompanion = false println(\"isCompanion = ${kClass.isCompanion}\") // isData = false println(\"isData = ${kClass.isData}\") // isFinal = true println(\"isFinal = ${kClass.isFinal}\") // typeParameters = [] println(\"typeParameters = ${kClass.typeParameters}\") // functions = [fun MyClass.make(kotlin.Int): kotlin.Int, fun MyClass.secretMake(): kotlin.Int, fun MyClass.equals(kotlin.Any?): kotlin.Boolean, fun MyClass.hashCode(): kotlin.Int, fun MyClass.toString(): kotlin.String] println(\"functions = ${kClass.functions}\") // primaryConstructor = fun &lt;init&gt;(kotlin.Int): MyClass println(\"primaryConstructor = ${kClass.primaryConstructor}\") // memberProperties = [val MyClass.first: kotlin.Int, val MyClass.immutableSecret: kotlin.Int, var MyClass.mutableSecret: kotlin.Int] println(\"memberProperties = ${kClass.memberProperties}\") // annotations = [@CustomAnnotation()] println(\"annotations = ${kClass.annotations}\") Creating Objects with Kotlin Reflection There are two types of classes in Reflection object creation. With a default constructor Without a default constructor Creating Objects with Reflection When There Is a Default Constructor If there is a default constructor, an error occurs when you try to create an object with Reflection without the default constructor. Let’s look at an example of how an error occurs. Note that you can create a Reflection object using the createInstance method. fun main() { val myClass = MyClass(5) // KClass is a generic type, so you need to handle inheritance with out. val kClass: KClass&lt;out MyClass&gt; = myClass::class val instance = kClass.createInstance() // Error: Exception in thread \"main\" java.lang.IllegalArgumentException: Class should have a single no-arg constructor: class MyClass println(\"instance = $instance\") } MyClass has a primary constructor called first, but an IllegalArgumentException error occurs because we tried to create it with Reflection. So, you can make it by giving a separate primaryConstructor using the call method as follows. fun main() { val kClass: KClass&lt;MyClass&gt; = MyClass::class val primaryConstructor = kClass.primaryConstructor // Force the primary constructor with call. val instance = primaryConstructor?.call(5) println(\"MyClass first = ${instance?.first}\") // MyClass first = 5 } If there is no default constructor, you can create an object with Reflection without the call method. Executing Functions with Kotlin Reflection Let’s use the object created above to execute functions in MyClass. Note that MyClass has the following two functions: A general fun function A private function Normally, only function 1 can be called, but if you create an instance object with Reflection, you can also call private function 2. Calling a Private Function from a Reflection Object When you use functions in the kClass object created above, you can get all the functions in the class. So, you can access private functions as follows: fun main() { val kClass: KClass&lt;MyClass&gt; = MyClass::class val primaryConstructor = kClass.primaryConstructor val instance = primaryConstructor?.call(5) // Find a function with the name \"secretMake\" from all the functions in the kClass. val secretMake: KFunction&lt;*&gt;? = kClass.functions.find { it.name == \"secretMake\" } // Since it is a private function, it is forcibly set to be accessible. secretMake?.isAccessible = true // Call the function. println(\"secretMake() = ${secretMake?.call(instance)}\") } Calling a Function with Parameters from a Reflection Object So, what if you need parameters for a function? You can call it as follows: fun main() { val kClass: KClass&lt;MyClass&gt; = MyClass::class val primaryConstructor = kClass.primaryConstructor val instance = primaryConstructor?.call(5) // Call the function with call. println(\"make() = ${instance?.call(\"make\", 10)}\") } Accessing and Modifying Variables with Kotlin Reflection Finally, let’s take a look at accessing member properties within a class object. For member properties, the way to access them is slightly different depending on whether they are val or var. More specifically, while both can be obtained in the same way, the code for modifying or inserting values is slightly different. Obtaining Member Property Values You can obtain member property values using memberProperties. Since MyClass has only private member variables, you need to set isAccessible just like with functions. The following code uses reflection to get the member variables of the class: fun main() { val kClass: KClass&lt;MyClass&gt; = MyClass::class val primaryConstructor = kClass.primaryConstructor val instance = primaryConstructor?.call(5) val immutableSecret = kClass.memberProperties.find { it.name == \"immutableSecret\" } immutableSecret?.isAccessible = true // immutableSecret = 2 println(\"immutableSecret = ${immutableSecret?.get(instance!!)}\") val mutableSecret = kClass.memberProperties.find { it.name == \"mutableSecret\" } mutableSecret?.isAccessible = true // mutableSecret = 3 println(\"mutableSecret = ${mutableSecret?.get(instance!!)}\") } val uses KProperty, while var uses KMutableProperty, so the reference classes are different. Therefore, for modifying var variables, you can use smart casting. fun main() { val kClass: KClass&lt;MyClass&gt; = MyClass::class val primaryConstructor = kClass.primaryConstructor val instance = primaryConstructor?.call(5) val immutableSecret = kClass.memberProperties.find { it.name == \"immutableSecret\" } immutableSecret?.isAccessible = true // immutableSecret = 2 println(\"immutableSecret = ${immutableSecret?.get(instance!!)}\") val mutableSecret = kClass.memberProperties.find { it.name == \"mutableSecret\" } mutableSecret?.isAccessible = true // mutableSecret = 3 println(\"mutableSecret = ${mutableSecret?.get(instance!!)}\") // treat mutableSecret as a KMutableProperty1.if (mutableSecret is KMutableProperty1) { mutableSecret.setter.call(instance, 10) // mutableSecret = 10 println(\"mutableSecret = ${mutableSecret.get(instance!!)}\") } } Unfortunately, even with reflection, you cannot modify val variables. Caution When Using Kotlin Reflection When using Android Studio, there is a possibility of code obfuscation, such as when using minifyEnabled as shown below: android { .. buildTypes { release { minifyEnabled true shrinkResources true proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' } } .. } Using minifyEnabled changes the names of classes and functions defined in the code to random names. (e.g. a class, fun b, etc.) However, when using reflection, classes and functions that use reflection should not be obfuscated. As seen above, this is because they are distinguished by name. In this case, you can use minifyEnabled and define proguard to specify the packages that should not be obfuscated. As shown in the code above, the file 'proguard-rules.pro' contains the locations, and the location of the file is as follows: For example, if all data classes in the data package use reflection: Adding the following -keep statement to proguard-rules.pro will prevent obfuscation of all classes and functions in the package: -keep class com.sample.activity.data.* { *;} In addition to this method of specifying packages at once, you can use the @Keep annotation to prevent obfuscation of individual classes or functions. @Keep data class TestData(val blogName: String) Summary It is a technology used to inspect a program’s classes at runtime. In other words, you can understand the internal structure of an object through instances and so on while the program is running. Annotations are a representative example. However, if you use it excessively, you may cause performance degradation because you have to inspect it every time you call a function or create an object.",
    "tags": "kotlin",
    "url": "/kotlin/2023/03/09/kotlin-reflection/"
  },{
    "title": "What is annotation in kotlin? custom annotation, built in annotation - 2",
    "text": "Understanding frequently used annotations in Kotlin Annotations are means to add metadata (additional functionality) to code non-invasively. Types of annotations in Kotlin Built-in annotations in Kotlin Meta annotations for providing information about annotations Custom annotations These are the three types of annotations. Built-in Annotations in Kotlin Kotlin already has many built-in annotations. for example, @Deprecated This annotation is used when you want to tell that a specific class, function, variable, etc. should not be used anymore. @Deprecated(\"It is deprecated\") fun sum(a: Int, b: Int) = a + b If you use the function that has @Deprecated, it will be expressed as follows. @JvmOverloads @JvmOverloads is a feature that automatically creates overloading functions as much as the default values set in the function or constructor parameters when using Kotlin Compiler. For example, let’s assume that one class has multiple constructors in Java: public class CustomView extends View { // Instantiating Viewpublic CustomView(Context context) { super(context); } // Inflate view using xmlpublic CustomView(Context context, AttributeSet attrs) { super(context, attrs); } // Set View's default attributes with defStyleAttrpublic CustomView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } } This can be expressed in Kotlin as follows: class CustomView : View {constructor(context: Context) : super(context) constructor(context: Context, attrs: AttributeSet) : super(context, attrs) constructor(context: Context, attrs: AttributeSet, defStyleAttr: Int) : super(context, attrs, defStyleAttr) // ... } Using @JvmOverloads, it can be expressed more simply as follows: class CustomView @JvmOverloads constructor(context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0) : View(context, attrs, defStyleAttr) { // ... } This can be formalized as follows: class SubClassName @JvmOverloads constructor(parameter list) : SuperClassName(argument list) @Qualifier @Qualifier is an annotation that is mainly used in Hilt or Dagger2. When providing dependencies using Hilt or Dagger2, it recognizes where dependencies go by looking at the value returned by the @Provides function. However, if there are more than one functions that return objects of the same form within a class, the compiler cannot know which function to provide. At this time, @Qualifier is used. For example, assuming that there is the following code: @Module public class NameModule{ @Provides // Function that returns String 1 String provideName1(){ return \"Charles\"; } @Provides // Function that returns String 2 String provideName2(){ return \"Runa\"; } } There are two functions that return strings within the same class. If you call it as follows for dependency provision: class Main{ @Inject // Although it is named name1, the compiler does not know that this is the return value of provideName1(). String name1; @Inject String name2; ... } An error occurs. At this time, you can express it as follows using the @Named annotation, which performs the same function as @Qualifier and is provided by the javax.inject package by default: @Module public class NameModule{ @Provides @Named(\"me\") String provideName1(){ return \"Charles\"; } @Provides @Named(\"you\") String provideName2(){ return \"Runa\"; } } class Main{ @Inject @Named(\"me\") String name1; @Inject @Named(\"you\") String name2; ... } Customizing @Qualifier You can customize @Qualifier as follows: public class WantQuailfierAutowired{ // Specify with the name myTarget@Qualifier(\"myTarget\") private final Target taget; // Call with the name myTargetpublic WantQuailfierAutowired(@Qualifier(\"myTarget\") Target target){ this.target = target; } } Meta Annotations that Constrain Annotations When defining an annotation, it is generally used as follows: // Simply put an annotation in front of the class name annotation class MyAnnotation However, you can add constraints to the annotation as follows: This is called a Meta Annotation. @Target(AnnotationTarget.FUNCTION, AnnotationTarget.CLASS) @Retention(AnnotationRetention.RUNTIME) @Repeatable @MustBeDocumented annotation class MyAnnotation The meaning of each Meta Annotation defined in the above code is as follows: @Target It is used to specify where the annotation can be used. The commonly used parameters are as follows. CLASS: Restrict to be used in class, interface, object, and annotation class. FUNCTION: Restrict to be used only in functions except constructors. FIELD: Restrict to be used only in fields, including backing fields. PROPERTY: Restrict the annotation to be used only in properties. TYPE: Restricts the annotation to be used anywhere. In addition, as shown in the code above, multiple Targets can be specified. @Retention It is used to limit the scope of the annotation, and there are three parameters. SOURCE: It is useful only during compile time and is not included in the built binary. It is used when it is useful only during development, such as @suppress that suppresses warnings during development and is not needed in binary. BINARY: It is included in both compile time and binary, but it cannot be accessed through reflection. RUNTIME: It is included in both compile time and binary and can be accessed through reflection. If @Retention is not indicated in Custom Annotation, the default is RUNTIME. @Repeatable Indicates whether an annotation can be used repeatedly for one element. @MustBeDocumented Indicates whether the annotation can be included in the generated documentation. It is mainly used when creating a library. It can be used as follows: @MustBeDocumented annotation class A_Annotation() annotation class B_Annotation() @A_Annotation @B_Annotation class TestClass() Although there is @MustBeDocumented in the A_Annotation() class, there is no such annotation in the B_Annotation() class. With Kotlin’s official documentation tool with dokka, you can automatically generate official documentation. Set the following in build.gradle: buildscript { repositories { jcenter() } dependencies { classpath \"org.jetbrains.dokka:dokka-gradle-plugin:0.9.14\" } } apply plugin: 'org.jetbrains.dokka' dokka { outputFormat = 'html' outputDirectory = \"$buildDir/html\" } Then, if you enter the following in the Terminal: &gt; ./gradlew dokka The following document will be automatically generated: If you look closely, you can see that only the @A_Annotation class with @MustBeDocumented has been documented. Basic Usage of Kotlin Annotations In Kotlin, annotations can be used with to apply multiple annotations. You can also apply multiple annotations at once using [ ] instead of applying them one by one with @. // equivalent to @Synchronized, @Strictfp @[Synchronized Strictfp] fun test() { } Defining Annotations in Kotlin In Kotlin, you can define annotations by adding “annotation” in front of classes, interfaces, etc. // defining an annotation by adding \"annotation\"annotation class MyAnnotation(val text: String) { // annotation parameter must always be defined with valcompanion object { } } // Calling the annotation using @ @MyAnnotation(\"testText\") fun myAnnotation() { } In part 2, we will discuss how to customize annotations and how to use them. Summary of Kotlin Annotations Annotations provide information to the compiler to check for syntax errors in the code. Annotations provide information to development tools or builders to automatically add code. Annotations provide information to execute specific functions at runtime.",
    "tags": "kotlin",
    "url": "/kotlin/2023/03/06/kotlin-annotation1/"
  },{
    "title": "Open Activity on top of Lock Screen - Android 13",
    "text": "Opening an Activity on the Lock Screen in Android 13 With the release of Android 12, the way to open an Activity on the lock screen has changed slightly. Additional permissions are required and the way it is implemented is different. Here is a quick and simple guide on how to do it. How to open an Activity on the lock screen in Android 13 To open an Activity on the lock screen in Android 13, you need to first modify the androidManifest. Modify the androidManifest.xml as follows: androidManifest.xml &lt;uses-permission android:name=\"android.permission.SYSTEM_ALERT_WINDOW\" /&gt; &lt;uses-permission android:name=\"android.permission.DISABLE_KEYGUARD\" /&gt; &lt;!-- Configure the target Activity as follows --&gt; &lt;activity android:name=\".ui.activity.OnAlarmActivity\" android:permission=\"android.permission.SYSTEM_ALERT_WINDOW\" android:excludeFromRecents=\"true\" android:exported=\"false\" android:launchMode=\"singleTask\" android:showOnLockScreen=\"true\"/&gt; Then define the Activity that will be displayed on the lock screen as follows: LockScreenOverlayActivity Define it as follows within onCreate(): // Open an Activity on the lock screen in Android 12 and up &amp; turn on the screen if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O_MR1) { setShowWhenLocked(true) setTurnScreenOn(true) (getSystemService(Context.KEYGUARD_SERVICE) as KeyguardManager).apply { requestDismissKeyguard(this@OnAlarmActivity, null) } } else { this.window.addFlags( WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD or WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED or WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON ) } Once you have completed these steps, you can call the Activity and it will be displayed on the lock screen. Summary Add SYSTEM_ALERT_WINDOW to the androidManifest.xml file and also to the Activity. Set setShowWhenLocked to true in the Activity. The method used to open an Activity on the lock screen is different for Android versions before and after Android 12.",
    "tags": "android",
    "url": "/android/2023/02/28/overlay-lock-screen/"
  },{
    "title": "Why do I need Android WorkManager and where should I use it?",
    "text": "Where and how should the Android Kotlin WorkManager be used? Why is WorkManager needed? Differences with other background processing technologies Where can WorkManager be used? How to use WorkManager WorkManager is a component created by Google to assist with background processing in Android’s Jetpack. As it is a recently developed technology, it has fixed various issues and bugs. It is safe to say that most background tasks in Android can be done using WorkManager. Why is WorkManager needed? Firstly, it is important to understand why apps running in the background on Android are automatically terminated. Memory usage in Android Although the Android kernel is based on the Linux kernel, the biggest difference is that it does not have Swap Space. What is Swap Space? Used when RAM is full Moves inactive data in memory to Swap Space Swap Space cannot replace RAM capacity increase Because Swap Space is located on hard drives with slow access times Since (by default) Android does not have Swap Space, it uses an OOM killer to forcibly terminate processes. The OOM killer forcibly terminates processes based on their Visible state and amount of consumed memory, to secure memory. All processes have their own oom_adj score assigned by the activity manager. This score is determined by the app’s state (Foreground, Background, Service, etc.). And the OOM killer terminates processes based on the following conditions. When free memory space is less than x, clean up processes with oom_adj values greater than y! Therefore, The higher the oom_adj value, the more easily the process is cleared by the OOM killer. In other words, The less memory an app consumes, the less likely the process is to be forcibly terminated. The second thing to understand is understanding of application states. Basically, if an app wants to do something continuously in the background, You should use the “Service” component. What is a service? There are several reasons why you should use the service. Notify the system that the process has a long-running task. Assign an appropriate oom_adj score when using the service. You can execute operations separately in a separate process using the service. Services are one of the four major components of Android apps. However, there is one problem here. Doing work in a separate process consumes a lot of battery power!!! Therefore, Google introduced the “Doze mode” and developed it more and more. (= Puts a tremendous amount of restrictions on background operations) Official description link for Doze mode Optimize for Doze and App Standby  |  Android Developers Test and optimize your app for the power-saving features in Android 6.0. developer.android.com Specifically, the following restrictions have been added to apps that can be registered in the app market. August 2018: All newly released apps must have API 26 (Oreo 8.0) or higher. November 2018: Existing apps must also have API 26 (Oreo 8.0) or higher. After 2019: The targetSdkVersion requirement will be improved every year. Whenever Android releases a new version each year, all apps must target that API level or higher. Therefore, the job API was created to replace the service. Differences in other background processing Appearance of JobScheduler ComponentName service = new ComponentName(this, MyJobService.class); JobScheduler mJobScheduler = (JobScheduler)getSystemService(Context.JOB_SCHEDULER_SERVICE); JobInfo.Builder builder = new JobInfo.Builder(jobId, serviceComponent) .setRequiredNetworkType(jobInfoNetworkType) .setRequiresCharging(false) .setRequiresDeviceIdle(false) .setExtras(extras).build(); mJobScheduler.schedule(jobInfo); JobScheduler schedules started jobs. At the appropriate time, the system starts MyJobService and performs the contents inside onStartJob(). However, JobScheduler can only be used in API 21 or higher. Afterwards, due to too many bugs, it is replaced by JobDispatcher. However, since there are devices that JobDispatcher does not work properly, It was then replaced by JobIntentService. However, JobIntentService also had a problem that it does not work exactly at the desired timing. So WorkManager was introduced. Appearance of WorkManager When you look at the above content, developers face issues where they must consider various things such as Android version and device model to create a background service. To solve these problems, WorkManager was created. WorkManager has the following characteristics. Provides system-based background processing APIs to simplify implementation. This API allows jobs to be performed in the background even when the app is not in the foreground. Developers do not have to worry about background processing. Therefore, it can replace most of the service functions such as Service and JobIntentService. Short tasks and long tasks can both be used. Trigger is possible by network status, battery status, etc. Can be used even in the foreground. Can be used with FCM. WorkManager has the following components. Configuration of WorkManager WorkManager Puts the job to be processed in its own queue and manages it. Since it is implemented as a singleton, you can receive the instance of WorkManager using getInstance() and use it. Worker An abstract class that inherits the processing code of the background task that needs to be processed. The code is written by overriding the doWork() method of this class. doWork() Once the job is completed, you must return one of the values of the enum defined within the Worker class called Result. There are three values: SUCCESS, FAILURE, RETRY. Depending on the value returned, WorkManager decides whether to finish the job, retry it, or define it as a failure and stop it. WorkRequest The individual job that will actually be requested through WorkManager. It contains information on how to process this job, such as the work to be done, whether it should be repeated, and the work execution conditions and constraints. Depending on whether it is repeated or not, it is divided into onTimeWorkRequest and PeriodicWorkRequest. onTimeWorkRequest Represents a job request for a job that will not be repeated, that is, a job that will be executed only once. PeriodicWorkRequest Represents a job request for a job that will be executed multiple times.",
    "tags": "android",
    "url": "/android/2023/02/18/what-workManager/"
  },{
    "title": "Defining and using Kotlin inline classes and functions",
    "text": "What is Variance? A concept that explains the relationship between types when the base type is the same but the type arguments are different. In the code below, List is the base type, and &lt;String&gt;, &lt;Any&gt; are the type arguments. List&lt;String&gt;, List&lt;Any&gt; However, even though String is a subtype of Any, List&lt;String&gt; is not a subtype of List&lt;Any&gt;. Therefore, the following code produces an error: fun addStringList(list: MutableList&lt;Any&gt;) { list.add(\"text\") } fun addNumberList() { val numbers = mutableListOf(1, 2, 3) // Error occurs here addStringList(numbers) } If the above code did not produce an error, unintended type arguments could be added to the list. Thus, although it may look like there is a subtype relationship, types that actually have no relationship with each other are called invariant. ⇒ This invariance only occurs in mutable collections. Therefore, immutable collections do not experience invariance. fun addNumberList() { val numbers =mutableListOf(1, 2, 3) // Error occurs here addStringMutableList(numbers) // Success with List&lt;Any&gt; val anyList =listOf&lt;Any&gt;(0, \"2\") } Why does covariance and invariance occur differently depending on whether a collection is immutable or mutable? Firstly, there are three types of generic types: Generic type producers that provide operations that only return an operation of type T and do not provide operations that receive an input of type T. = i.e., when the generic type only acts as a producer. Generic type consumers that only receive input of type T and never return output of type T. = i.e., when the generic type only acts as a consumer. Types that are not included in either of the above two categories. = If all sub-values can be inserted, it is impossible to maintain a subtype relationship without breaking type safety, which is why it is difficult to use mutable collections. For example: fun test() { val stringNode = TreeNode(\"Hello\") // Error occurs due to covariance val anyNode: TreeNode&lt;Any&gt; = stringNode // There is no error in the action of receiving values itself anyNode.addChild(123) } So why are immutable types like List covariant? Immutable collections only produce T type values and do not consume them. Therefore, if it is defined as List, it just returns Any. Thus, most immutable collections maintain covariance. Assigning covariance and contravariance using in and out projections As seen in the example above, even though Int inherits from Number and Int’s superclass is Number, there is no inheritance relationship in generics. = invariance In general use, Int inherits from Number. = covariance Out Projections Out projections can be used to change from invariance to covariance. class Rectangle&lt;out T: Number&gt;(val width: T, val height: T) { } fun main(args: Array&lt;String&gt;) { // Declare Double for generics val derivedClass = Rectangle&lt;Double&gt;(10.5, 20.5) // Rectangle&lt;Double&gt; is recognized as a subclass of Rectangle&lt;Number&gt; // So no error occurs val baseClass : Rectangle&lt;Number&gt; = derivedClass } In Projections In is the opposite of out. That is, the two types can be reversed. For example, in the previous example, Rectangle was a subclass of Rectangle, but using in projections, Rectangle can be a subclass of Rectangle. class Rectangle&lt;in T: Number&gt;(val width: T, val height: T) { } fun main(args: Array&lt;String&gt;) { val baseClass = Rectangle&lt;Number&gt;(10.5, 20.5) // Number class can be put into Double val derivedClass : Rectangle&lt;Double&gt; = baseClass } This is called contravariance. Summary Variance: A concept that explains the relationship between types when the base type is the same but the type arguments are different. Why covariance and invariance occur differently depending on whether a collection is immutable or mutable is due to the role of generics. Covariance and contravariance can be assigned freely using in and out projections.",
    "tags": "kotlin",
    "url": "/kotlin/2023/02/18/kotlin-variance/"
  },{
    "title": "[Solved] Deprecated Gradle features were used in this build, making it incompatible with Gradle 8.0",
    "text": "Deprecated Gradle features were used in this build, making it incompatible with Gradle 8.0. How to resolve it Occurred during build Occurred when running command line in terminal Solution Actually, I think Android Studio already suggests a solution. You can use ‘–warning-mode all’ to show the individual deprecation warnings and determine if they come from your own scripts or plugins. In other words, ignore compatibility with Gradle and run by giving the option ‘–warning-mode all’. You can do the following: Open Android Studio’s Preferences on a Mac. Then go to Build, Execution, Deployment -&gt; Compiler There is a Command line Options and you can put the following code: --warning-mode=all --stacktrace After that, Press file -&gt; Invalidate Caches / Restart Reset the cache and restart it. You can see that it works normally.",
    "tags": "android",
    "url": "/android/2023/02/17/deprecated-error/"
  },{
    "title": "Preventing Automatic Focus on Android EditText",
    "text": "Preventing Automatic Focus on Android EditText Prevent automatic focus on EditText when the layout is clicked. The EditText is given focus automatically. When a window with EditText is opened, the keyboard is automatically displayed. If you want the keyboard to be displayed automatically, just use it as it is. However, there are times when you need to prevent automatic focus. To prevent this phenomenon: You only need to add 2 lines to the xml code. android:focusable=”true” android:focusableInTouchMode=”true” Where should you add it? Generally, add it to the parent layout. Alternatively, you can add it where you want. Example &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;LinearLayout xmlns:android=\"&lt;http://schemas.android.com/apk/res/android&gt;\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:focusable=\"true\" android:focusableInTouchMode=\"true\"&gt; &lt;EditText android:id=\"@+id/et01\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"/&gt; &lt;/LinearLayout&gt; As you can see in the LinearLayout(parent layout) Two more lines are added at the end. android:focusable=”true” android:focusableInTouchMode=”true” Because of these attributes, when the screen appears, focus is given to LinearLayout instead of EditText. Therefore, you can prevent the keyboard from automatically appearing.",
    "tags": "android",
    "url": "/android/2023/02/14/focus-editText/"
  },{
    "title": "Android OutOfMemoryError: How to resolve Java heap space errors",
    "text": "Resolving OutOfMemoryError: Java heap space error in Android Causes of OutOfMemoryError: Java heap space Solutions for OutOfMemoryError: Java heap space Causes of OutOfMemoryError: Java heap space This error is not often encountered when working on personal projects. The reason is that it occurs when there is insufficient space in the Heap area. It occurs when there are large files (Res, Raw) in the project. Therefore, one solution is to optimize these files, but it is not easy as it takes a lot of time and there is much to do. However, there is a simple way to solve this problem, which is to increase the Heap area. Solutions for OutOfMemoryError: Java heap space Increasing the Heap area can solve the OutOfMemoryError: Java heap space problem, and the following is the method: Look for the gradle.properties file. Find jvmargs and change it to the following: org.gradle.jvmargs=-Xms4096m -Xmx10248m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8 To increase the effect properly, both Xms and Xmx need to be increased. After this, run the project again to confirm that it is working properly.",
    "tags": "android",
    "url": "/android/2023/02/04/outOfMemory/"
  },{
    "title": "Create and deploy Android libraries as jitpack",
    "text": "Creating an Android library and distributing it with jitpack How to create your own library using Android Studio How to use the created library in a local environment How to distribute the created library with jitpack Creating a library 1. Create a project with an empty activity using the usual method. 2. Create a new module for the library. Create a new module at the top level. Make sure the package name is the same as the project’s package name. Remember the name of the newly created module. 3. Add a new file to the new module. This file will contain the definition of the library. 4. Insert simple functionality into the file. object TestLibrary { fun showToast(context: Context, message: String) { Toast.makeText(context, message, Toast.LENGTH_SHORT).show() } } 5. Add the library that was just added to the main module’s build.gradle. The following is how to add it. Click File &gt; Project Structure. Click Dependencies &gt; app &gt; +. Click Module Dependency. Add the newly created library. Execute Sync Project with gradle files. Note that mine looks like this: dependencies { ... implementation project(path: ':PermissionCatcherLibrary') } Once you have done this, you can use the code of the newly created module in the original main module file. Using the created library (locally) You can use the locally added library in the default MainActivity as follows: class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) TestLibrary.makeToast(this, \"Library test\") } } Setting up for distribution of the library As it is now, it can only be used locally and cannot be distributed. To distribute it, the following settings are required. 1. Set the targetSDK to the latest version. To distribute the initial library with jitpack, the targetSDK must be set to the latest version. The latest targetSDK as of now is 33, so change it to that. This needs to be done for both the main app and the library’s build.gradle. android{ compileSdk 33 ..... defaultConfig { minSdk 26 targetSdk 33 .... } } 2. Set up the necessary settings in the library’s build.gradle. Modify the Project-level gradle Add the following code to the beginning. buildscript { dependencies { classpath 'com.github.dcendents:android-maven-gradle-plugin:2.1' } } Modify the App-level gradle Modify plugins as follows. plugins { id 'com.android.library' id 'org.jetbrains.kotlin.android' id 'maven-publish' } Add publishing information here. Add the following code directly below dependencies afterEvaluate { publishing { publications { // Creates a Maven publication called \"release\". release(MavenPublication) { // Applies the component for the release build variant. from components.release // You can then customize attributes of the publication as shown below. groupId = 'your github name' = Example: mmol93 artifactId = 'name of the library to be released' = Example: TestLibrary version = 'version' = Example: 1.0.0 } // Creates a Maven publication called “debug”. debug(MavenPublication) { // Applies the component for the debug build variant. from components.debug groupId = 'your github name' = Example: mmol93 artifactId = 'name of the library to be released' = Example: TestLibrary version = 'version' = Example: 1.0.0 } } } } Uploading the project to Github To distribute with jitpack, the following steps are required on Github: Upload to Github - we will omit the explanation of this part. Release Release on Github You can release using Create a new release as shown in the following video. You can see that the release is activated as shown below. The code below is added to setting.gradle. maven { url 'https://jitpack.io' } And you can add dependency that you just created.",
    "tags": "android",
    "url": "/android/2023/01/19/library-jitpack/"
  },{
    "title": "How to get Notification authorization on Android 13 and what changes.",
    "text": "Changes in Notification in Android 13 POST_NOTIFICATIONS (Notification Permission) can be added from Target SDK API 33 or higher If an app with Target SDK API 32 or lower is installed on an Android 13 device, the Notification permission request popup will appear automatically when registering a Notification Channel If an app with Target SDK API 33 or higher is installed on an Android 13 device, the Notification permission request can be displayed at the developer’s desired timing If an app with Target SDK API 33 or higher is installed on an Android 12 or lower device, it can be used without requesting the Notification permission as before If an API 32 app is updated to 33 and the user has already agreed to the notification permission, it will be allowed by default after the update, but there are exceptions There may be cases where it is not automatically allowed depending on the device and you need to request permission again Therefore, it is recommended to include a check to see if the Notification permission is granted. Cautions for Notification Permission Request Popup For apps with API 32 or lower, if the user presses the Don’t allow button when the system automatically displays the permission popup, the popup will not appear even if the app is restarted. For apps with API 33 or higher, if the app displays the permission popup, it can continue to display the permission popup until the user presses the Don’t allow button twice. If the user can no longer display the popup by pressing the Don’t allow button, they must go to the app settings and grant permission. Registering the App as Needing Notification Permission AndroidManifest.xml &lt;manifest ...&gt; &lt;uses-permission android:name=\"android.permission.POST_NOTIFICATIONS\"/&gt; &lt;application ...&gt; ... &lt;/application&gt; &lt;/manifest&gt; Add the above permission to AndroidManifest.xml. Perform “Sync project with gradle files”. Change compileSdk to 33 The compileSdk in the app-level build.gradle must be changed to 33 The targetSdk also needs to be changed to 33 android { compileSdk 33 defaultConfig { applicationId \"com.example.selftest\" minSdk 23 targetSdk 33 versionCode 1 versionName \"1.0\" testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\" } Defining Notification Define the Notification Channel and Builder for the Notification From SDK version 26 or higher, a channel must be defined to use Notification Send Notification using the Builder fun makeAlarmNotification(context: Context, messageBody: String) { Timber.d(\"make notification\") // Open MainActivity when notification is clickedval intent = Intent(context, MainActivity::class.java) intent.flags = Intent.FLAG_ACTIVITY_CLEAR_TASK or Intent.FLAG_ACTIVITY_NEW_TASK val pendingIntent = PendingIntent.getActivity( context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE ) // Define the Notification channel idval channelId = \"channel1\" val channelName = \"channel name\" // Define the Notificationval notificationBuilder = NotificationCompat.Builder(context, channelId) .setSmallIcon(R.drawable.ic_bottom_menu_search) .setContentTitle(\"notification title\") .setContentText(messageBody) .setAutoCancel(false)// Prevent it from being deleted completely .setSound(null) .setContentIntent(pendingIntent) .setPriority(NotificationCompat.PRIORITY_DEFAULT) .setOngoing(true)// Keep the alarm on // Create the Notification using the defined content and channelval notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager // A channel must be specified when creating a notification for Android SDK 26 or higherif (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) { val channel = NotificationChannel( channelId, channelName, NotificationManager.IMPORTANCE_DEFAULT ) notificationManager.createNotificationChannel(channel) } // Show the Notification notificationManager.notify(100, notificationBuilder.build()) } Getting Notification Permission To display a Notification in Android 13 or higher, you must request and obtain permission. Notification permissions can be obtained in the following ways. FirstFragment.kt Display the Notification permission request popup when the button is pressed. class FirstFragment : Fragment() { companion object { const val DENIED = \"denied\" const val EXPLAINED = \"explained\" } private var binding: FragmentFirstBinding by autoCleared() // Create an Activity Callback object for permission requestsprivate val registerForActivityResult = registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) { permissions -&gt; val deniedPermissionList = permissions.filter { !it.value }.map { it.key } when { deniedPermissionList.isNotEmpty() -&gt; { val map = deniedPermissionList.groupBy { permission -&gt; if (shouldShowRequestPermissionRationale(permission)) DENIED else EXPLAINED } map[DENIED]?.let { // When permission is simply denied } map[EXPLAINED]?.let { // When the permission request is completely blocked (usually open the app details screen) } } else -&gt; { // When all permissions are allowed } } } override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View { binding = FragmentFirstBinding.inflate(inflater, container, false) return binding.root } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) binding.button.setOnClickListener { val action = FirstFragmentDirections.actionFirstFragmentToThirdFragment() findNavController().navigate(action) } // Request Notification permission when the button is clicked binding.freeButton.setOnSingleClickListener { if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) { registerForActivityResult.launch( arrayOf(Manifest.permission.POST_NOTIFICATIONS) ) } makeAlarmNotification(requireContext(), \"notification\") } } } This method can be used not only in Fragment but also in Activity. Summary For existing apps, the window for requesting permission automatically appears when registering a Notification Channel. However, if permission is not granted at this stage, permission cannot be requested twice. If you have set SDK 33 or higher as the target, you must include a feature that requests permission.",
    "tags": "android",
    "url": "/android/2023/01/17/notification-permission/"
  },{
    "title": "Usage of Scope functions apply, with, let, also, run",
    "text": "Usage of Scope functions apply, with, let, also, run Internal structure of each Scope function (including differences between apply and with) Examples and applications of usage Precautions to take when using Scope functions Internal Structure of Standard Extension Functions (Scope Functions) inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R { return receiver.block() } inline fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T { block(this) return this } inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T { block() return this } inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R { return block(this) } inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R { return block() } with Internal structure inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R { return receiver.block() } with is not used as an extension function Instead, it is an explicit receiver that receives T and must be explicitly passed as a parameter Therefore, this or it is not used When returning, it implicitly passes the receiver it executed block on as the extension function of T and returns it In other words, it returns the applied object apply Internal structure inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T { block() return this } also is used as an extension function The receiver is implicitly passed as (this) Returns the object itself (this) that was applied let Internal structure inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R { return block(this) } It is an extension function that passes the explicit receiver (it) as a parameter Returns the result of executing block also Internal structure inline fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T { block(this) return this } It is an extension function that passes the explicit receiver (it) as a parameter This is the biggest difference from apply Therefore, the object can be specified using this Returns the object itself that was extended run Internal structure inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R { return block() } The receiver is implicitly passed as (this) Returns the result of executing block The original object is not affected This is the difference from apply Usage of apply, with, let, also, run apply Used when you want to extend and specify the result fun main() { val me = Person().apply { name = \"Nishant\" age = 19 gender = 'M' } println(me) } with Used for almost the same purpose as apply fun main() { val me = with(Person()) { name = \"Nishant\" age = 19 gender = 'M' } println(me) } let Useful when you want to use the value in multiple places Can also be used for nullPointCheck using ?:(elvis operator) fun main() { val age = readLine()?.toIntOrNull() age?.let { println(\"You are $it years old\") } ?: println(\"Wrong input!\") } also Useful when you want to use the applied value in a limited place ( { } ) fun main() { Person( name = \"Nishant\", age = 19, gender = 'M' ).also { println(it) } } run Useful when you don’t want to specify one by one with it like let That is, when you want to use the internal values of the value in multiple places fun main() { val me = Person( name = \"Nishant\", age = 19, gender = 'M' ) me.run { println(\"My name is $name and I am $age years old.\") } } Summary of Scope Functions apply, with, let, also, run Summarizing, we have: apply Used when you want to extend and specify the result with Used for almost the same purpose as apply let Useful when you want to use the value in multiple places Can also be used for nullPointCheck using ?:(elvis operator) also Useful when you want to use the applied value in a limited place ( { } ) run Useful when you don’t want to specify one by one with it like let That is, when you want to use the internal values of the value in multiple places",
    "tags": "kotlin",
    "url": "/kotlin/2023/01/16/kotlin-scope-function/"
  },{
    "title": "Will Android Kotlin recycle if it keeps making the same variables?",
    "text": "Will Kotlin recycle the same variable if it is repeatedly created? Create a function that generates variables every time it is called. Check the memory address value of the variable created while continuously calling the function. Check whether the same variable is reused or a new address is assigned through the address value. Writing Test Code Basically, since Kotlin does not have pointers like C, It is not possible to obtain the address value where the variable is stored… However, in case of collections, it is possible to output the address value, So, as in the example below, we create a variable (list) every time a button is clicked. binding.freeButton.setOnSingleClickListener { val testValue = listOf(0, 1, 2) Timber.d(\"clicked time: ${Calendar.getInstance()}\") } Confirm the Variable Address through Test and Debugging Looking at the results through debugging, First call result Second call result Third call result It can be seen that every time you click the button, a new space is allocated to the memory. Therefore, if you need to define a variable every time you call it in the function, you need to check whether you need to call it every time you click the button.",
    "tags": "kotlin",
    "url": "/kotlin/2023/01/08/repeat-variable/"
  },{
    "title": "Usage of registerForActivityResult &amp; Reason of startActivityForResult is deprecated",
    "text": "Using registerForActivityResult and the reason for the deprecation of startActivityForResult Find out why startActivityForResult has been deprecated. Open and close an Activity using registerForActivityResult and receive callbacks. Open the gallery and receive a picture file using registerForActivityResult. Reasons for the deprecation of startActivityForResult Previously, startActivityForResult was defined within an Activity or Fragment. As a result, if the new Activity used a lot of memory, there were cases where the previous Activity was killed and the callback was not received. To prevent this, the part that runs the new Activity and the part that handles the callback were separated. This is registerForActivityResult. Implementing registerForActivityResult We will implement two cases: Use registerForActivityResult to open and close an Activity, receive data and callbacks, and display the received data on the existing screen. Use registerForActivityResult to open the gallery, receive the selected picture file, and display it on the existing screen. Using registerForActivityResult to open an Activity The basic layout is as follows: FirstFragment.kt Click the Button in the Fragment to open an Activity. Display the data received from the callback in a TextView. FirstFragment.kt // registerForActivityResult must be declared and defined in the global section of FirstFragment.kt.private var resultLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result -&gt; if (result.resultCode == Activity.RESULT_OK) { // Print the received String data when it is not null or blank. when { !result.data?.getStringExtra(\"data\").isNullOrBlank() -&gt; { binding.textView.text = result.data?.getStringExtra(\"data\") binding.textView2.text = \"Returned from TestActivity\" } } // Define in onViewCreated binding.openActivity.setOnSingleClickListener { val intent = Intent(context, FirstActivity::class.java) // Specify which Intent to open here.// Could be a general Activity or an image Intent. resultLauncher.launch(intent) } FirstAcitivty.kt An Activity opened using registerForActivityResult. When the Close button is clicked, send data with the callback to the previous screen. // ActivityResultLauncher must be declared and defined in the global section.private val resultLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result -&gt; if (result.resultCode == Activity.RESULT_OK) { // Print the received data in the log. Timber.d(result.data?.getStringExtra(\"data\")) } } // onCreate binding.button.setOnSingleClickListener { // Send data when exiting the Activity. intent.putExtra(\"data\", \"Data sent from FirstActivity\") setResult(RESULT_OK, intent) finish() } When you click the Close button in FirstActivity and return to FirstFragment, the result shows that the callback is received and the received data is displayed on the screen. Using registerForActivityResult to open the gallery and receive a picture file FirstFragment.kt // The following variable is a global variable.private var bookImageBitmap: Bitmap? = null // ActivityResultLauncher must be declared and defined outside.private var resultLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result -&gt; if (result.resultCode == Activity.RESULT_OK) { // Print the received String data when it is not null or blank. when { !result.data?.getStringExtra(\"data\").isNullOrBlank() -&gt; { binding.textView.text = result.data?.getStringExtra(\"data\") binding.textView2.text = \"Returned from TestActivity\" } // Check if there is data received after returning from the gallery. result.data?.data != null -&gt; { result.data?.data?.let { uri -&gt; if (result.resultCode == AppCompatActivity.RESULT_OK) { // Convert the picture data to a Bitmap. bookImageBitmap = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) { ImageDecoder.decodeBitmap( ImageDecoder.createSource( requireContext().contentResolver, uri ) ) } else { MediaStore.Images.Media.getBitmap( requireContext().contentResolver, uri ) } Glide.with(requireContext()).load(uri) .placeholder(R.drawable.ic_bottom_menu_search) .into(binding.imageView) } } } } } } // Define in onViewCreated binding.openImageActivity.setOnSingleClickListener { // Define an Intent to open the gallery. val intent = Intent(Intent.ACTION_GET_CONTENT) intent.type = \"image/*\" intent.flags = Intent.FLAG_ACTIVITY_SINGLE_TOP or Intent.FLAG_ACTIVITY_NO_HISTORY resultLauncher.launch(intent) } When you click on openImageActivity to open the gallery: Using registerForActivityResult and the reason for the deprecation of startActivityForResult Find out why startActivityForResult has been deprecated. Open and close an Activity using registerForActivityResult and receive callbacks. Open the gallery and receive a picture file using registerForActivityResult.",
    "tags": "android",
    "url": "/android/2023/01/07/registerForActivity/"
  },{
    "title": "Defining and using Kotlin inline classes and functions",
    "text": "What is inline code? It is a way to define a function or class within its calling code instead of being compiled into a separate function or class. Inline classes are mainly used when creating a Wrapping Class. Using inline classes loses its meaning if boxing occurs frequently. What is an inline code? It is a way to define a function or class within its calling code instead of being compiled into a separate function or class. Comparison of code when inline and not inline Defining a function without using inline and then calling it fun fn(n1: Int, n2: Int): Int { return n1 + n2 } fun main() { val result = fn(1, 2) println(result) } Compilation Result // A separate function is created just like what was defined in Kotlinpublic static final int fn(int n1, int n2) { return n1 + n2; } public static final void main() { int result = fn(1, 2); boolean var1 = false; System.out.println(result); } Calling a function defined as inline inline fun fn(n1: Int, n2: Int): Int { return n1 + n2 } fun main() { val result = fn(1, 2) println(result) } Compilation Result public static final int fn(int n1, int n2) { int $i$f$fn = 0; return n1 + n2; } // The defined function is executed within mainpublic static final void main() { byte n1$iv = 1; int n2$iv = 2; int $i$f$fn = false; int result = n1$iv + n2$iv; boolean var4 = false; System.out.println(result); } As such, inline code puts the defined class/function into where it is called, which leads to great performance improvement when receiving functional arguments. Notes and Tips Using inline functions will make the compiled code longer. It is more effective when the target function is relatively small. A significant portion of the higher-order functions provided by the Kotlin standard library are inline functions. The following higher-order function is effective when applied: fun main(args: Array&lt;String&gt;) { println(indexOf(intArrayOf(4, 3, 2, 1)){ it&lt; 3})// 2// The compiled look of the inline indexOf() function is the followingval number =intArrayOf(4,3,2,1) var index = -1 for (i in number.indices){ if (number[i] &lt; 3){ index = i break } } println(index)// 2 } inline fun indexOf(numbers: IntArray, condition: (Int) -&gt; Boolean): Int { for (i in numbers.indices) { if (condition(numbers[i])) return i } return -1 } However, inline functions come with limitations: Cannot receive arguments that can be null. Cannot receive private arguments. Cannot be used when encapsulation is necessary, as the function will be placed within the class. Why is inline class necessary? Inline classes are mainly used when creating a Wrapping Class. Suppose you want to convert a basic type such as UnixMillis, which is essentially a Long, into java.util.Calendar, or perform conversions for date and time. The first way is to create a general Wrapper Class: class UnixMillis(private val millis: Long) { // Convert the received mills data to Calendarfun toCalendar(): Calendar { return Calendar.getInstance().also { it.timeInMillis = millis } } } If you decompile this, you can get the following Java code: public static final void main() { // Create a UnixMillis object UnixMillis unix = new UnixMillis(System.currentTimeMillis()); // Perform Calendar conversion using the object Calendar calendar = unix.toCalendar(); // This is not an optimized method as it creates a Calendar object every time } This way, every time you use the toCalendar() function, you have to create an object, which is burdensome. Now, let’s try to create it using an inline class // Just add inline in front of the class and that's it.inline class UnixMillis(private val millis: Long) { fun toCalendar(): Calendar { return Calendar.getInstance().also { it.timeInMillis = millis } } } When you decompile this into Java code, you get the following: public static final void main() { // Create a Long object instead of a UnixMillis object long unix = UnixMillis.constructor-impl(System.currentTimeMillis()); // Use the code inside the function being called (optimized only) Calendar calendar = UnixMillis.toCalendar-impl(unix); } By using an inline class, you can see that the object is not created every time. Note Inline classes must have only one argument in the primary constructor, which must be declared with var or val. Inline classes cannot have an init. Inline classes cannot have backing field (e.g. lateinit, delegated, etc.). Starting from Kotlin 1.5, you can also use value classes. For JVM backend, you must add @JvmInline. Why you shouldn’t use inline classes recklessly As mentioned earlier, inline classes are mainly used when creating a Wrapping Class. When you use a Wrapping Class, it boxes and unboxes the internal value every time it is used. If you look at the following inline class example: inline class Password(val value: String) Boxing means storing value as a Password object. Unboxing means getting the value from Password. That is, if boxing occurs frequently, using an inline class loses its meaning. Example of boxing multiple times interface Iinline class Foo(val i: Int) : I fun asInline(f: Foo) {} fun &lt;T&gt; asGeneric(x: T) {} fun asInterface(i: I) {} fun asNullable(i: Foo?) {} // The id function just returns the received value as it isfun &lt;T&gt; id(x: T): T = x fun main() { val f = Foo(42) // unboxed: Since f is an object of Foo, you can use it as is// Therefore, there is no need to box/unbox again when using f asInline(f) // Basically, when you don't receive an inline class object as a function argument// You have to box it once and then unbox it again// boxed: Since the Foo object is received as a generic type T, boxing is necessary// Therefore, you have to box it once and then unbox it again to use f asGeneric(f) // boxed: An inline class object must be converted to the corresponding interface// Therefore, you have to box it once to use f asInterface(f) // boxed: When there is a nullable inline class object, boxing is necessary// Therefore, you have to box it once and then unbox it again to use f asNullable(f) // unboxed: Since no boxing is necessary, you can use it as is// Therefore, you don't have to box/unbox again when using f val x = id(f) }",
    "tags": "kotlin",
    "url": "/kotlin/2023/01/07/inline/"
  },{
    "title": "Lifecycle changes when moving the screen with Navigation",
    "text": "Logs are output for each lifecycle start. 1. Lifecycle changes when first executed By default, each override function is called first, and then the lifecycleScope for each state is called. onCreate -&gt; onStart -&gt; onResume 2. Lifecycle changes when confirming the currently running app screen (square button) and returning This does not affect the lifecycle. 3. Lifecycle changes when going to the Home screen and returning (Go to Home) -&gt; onPause -&gt; (Return) -&gt; onStart -&gt; onResume 4. Lifecycle changes when returning after viewing a completely different screen onPause -&gt; onStart -&gt; onResume However, if each lifecycleScope is output only once with lifecycleScope.launchWhenCreated { } instead of specifying with repeatOnLifecycle, it will be output only once. 5. Conclusion The lifecycle of Activity is output first, and then the lifecycle of lifecycleScope is output. Fragment Check the lifecycle changes in Fragment when moving screens. The main problem that occurs in Fragment is that the same data is set twice due to loading the data being observed again when returning from a different Fragment. Consider measures to prevent this by checking the lifecycle. Test process Create two fragments, FirstFragment and SecondFragment. Attach logs to FirstFragment to see the lifecycle. Move from FirstFragment to SecondFragment and return to FirstFragment. Check the lifecycle changes during the return process. Use navigation to move between fragments. [Full code of FirstFragment] class FirstFragment : Fragment() { private lateinit var binding: FragmentFirstBinding override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View { binding = FragmentFirstBinding.inflate(inflater, container, false) return binding.root } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) Timber.d(\"FirstFragment onViewCreated\") binding.nextFragment.setOnClickListener { val action = FirstFragmentDirections.actionFirstFragmentToSecondFragment() findNavController().navigate(action) } } // Log output according to life cycle change of fragment override fun onStart() { super.onStart() Timber.d(\"FirstFragment onStart\") } override fun onResume() { super.onResume() Timber.d(\"FirstFragment onResume\") } override fun onPause() { super.onPause() Timber.d(\"FirstFragment onPause\") } override fun onStop() { super.onStop() Timber.d(\"FirstFragment onStop\") } override fun onDestroy() { super.onDestroy() Timber.d(\"FirstFragment onDestroy\") } } 1. Lifecycle changes when opening the first fragment onViewCreated -&gt; onStart -&gt; onResume 2. Lifecycle changes when using navigation to move from the first fragment to the second fragment When moving with the graph, the previous fragment remains in the stop state without being destroyed. onPause -&gt; onStop 3. Lifecycle changes when using navigation to return from the second fragment to the first fragment Although it was not destroyed, it runs from onViewCreated again. onViewCreated -&gt; onStart -&gt; onResume 4. Lifecycle changes when completely closing the activity The Fragment is destroyed only when the Activity is completely closed. onPause -&gt; onStop -&gt; onDestroy Summary of each screen’s lifecycle The lifecycle of Activity is output first, and then the lifecycle of lifecycleScope is output. In Fragment, the previous fragment remains in the stop state without being destroyed when moving with the graph, and it runs onViewCreated again when returning.",
    "tags": "android",
    "url": "/android/2022/12/24/fragment_navigation/"
  },{
    "title": "Automatically publish a license using LicenseTools Plugin",
    "text": "What is LicenseToolsPlugin Automatically generates license information for the libraries in use The generated file is output as an html file License is disclosed by displaying the output html file on the screen An open source created by a company called Cookpad in Japan LicenseToolsPlugin GitHub address GitHub - cookpad/LicenseToolsPlugin: Gradle plugin to check library licenses and generate license pages for Android Gradle plugin to check library licenses and generate license pages for Android - GitHub - cookpad/LicenseToolsPlugin: Gradle plugin to check library licenses and generate license pages for Android github.com Declaration of necessary Dependency // Declare in the project level gradle buildscript { repositories { maven { url \"&lt;https://plugins.gradle.org/m2/&gt;\" } } dependencies { classpath \"gradle.plugin.com.cookpad.android.plugin:plugin:1.2.6\" } } // Declare in the app level gradle apply plugin: \"com.cookpad.android.plugin.license-tools\" How to use How to use Creating a Licenses.yml file Enter the following in the Android Studio terminal ./gradlew updateLicenses If successful, you can see that the ./app/licenses.yml file has been created You need to set the view to Project rather than Android to see it. If failed, try ./gradlew checkLicenses first and try again. Checking the generated file Enter the following in the Android Studio terminal ./gradlew checkLicenses If successful, you can see the BUILD SUCCESSFUL message. Creating the licenses.html file Enter the following in the Android Studio terminal ./gradlew generateLicensePage If successful, you can see that the ./app/src/main/assets/licenses.html file has been created. You need to set the view to Project rather than Android to see it. Issues and Precautions that may arise during LicenseToolsPlugin setup Process of creating license files Create the licenses.yml file through updateLicenses. ./gradlew generateLicensePage creates a licenses.html file by referring to licenses.yml. Therefore, most problems arise due to the contents of licenses.yml. When the error “Could not generate the copyright statement” occurs Add skip: true to the corresponding artifact. This means that the license generation of the library will not be done when generating. Or put a value in copyrightHolder. If it was first created, copyrightHolder contains meaningless values such as #COPYRIGHT_HOLDER#. However, you can delete this and put the name of the company or individual who actually owns or created the library, such as Google. LicenseToolsPlugin does not set up all libraries. Check which libraries were automatically set up as html through the app after outputting. Displaying the generated html file Simply showing the generated html file is the end. It will look like the following html.",
    "tags": "android",
    "url": "/android/2022/12/22/license-tool-plugin/"
  },{
    "title": "What is Solid Design in Android",
    "text": "What is Solid Design? S: Single Accountability Principle (SRP) = Single Accountability Principle O : OPENING/CLOSING PRINCIPLES (OCP) L : Liskov Replacement Principle (LSP) = Liskov Replacement Principle I : Interface Segmentation Principle = Interface Separation Principle D : Dependency Inversion Principle (DIP) = Dependency Inversion Principle SOLID design allows you to create code that’s easy to follow and easy to change. However, it is not necessary to apply the SOLID design when creating all apps, and you can use it appropriately for your project. S: Single Accountability Principle (SRP) It is a part of the SOLID design that corresponds to S. The module should handle only one thing. There is a source file as below. class Order { fun sendOrderUpdateNotification() { // sends notification about order updates to the user. } fun generateInvoice() { // generates invoice } fun save() { // insert/update data in the db } } The Order Class above has multiple responsibilities. A source file (module) called Oder contains functions that have multiple roles. Therefore, it can be changed as follows. data class Order( val id: Long, val name: String, // ... other properties. ) class OrderNotificationSender { fun sendNotification(order: Order) { // send order notifications } } class OrderInvoiceGenerator { fun generateInvoice(order: Order) { // generate invoice } } class OrderRepository { fun save(order: Order) { // insert/update data in the db. } } When used, it can be used by delegating responsibility to one class as follows class OrderFacade( // 1 class parameter has 1 responsibility private val orderNotificationSender: OrderNotificationSender, private val orderInvoiceGenerator: OrderInvoiceGenerator, private val orderRepository: OrderRepository ) { fun sendNotification(order: Order) { // sends notification about order updates to the user. orderNotificationSender.sendNotification(order) } fun generateInvoice(order: Order) { // generates invoice orderInvoiceGenerator.generateInvoice(order) } fun save(order: Order) { // insert/update data in the db orderRepository.save(order) } } However, giving a single responsibility to all classes in this way will cause class files to grow exponentially. That’s why it’s better to apply the SOLID design properly than to apply it completely… O - OCP(Open/Closed Principle) It is a part of the SOLID design that corresponds to O. The Open/Closed Principle definition is as follows. Software artifacts must be opened for expansion but closed for modification. That means the operation of the software artifact should be expandable without modification. Example of violating OCP enum class Notification { PUSH_NOTIFICATION, EMAIL } class NotificationService { fun sendNotification(notification: Notification) { // Perform other tasks according to the value of the notification. when (notification) { Notification.PUSH_NOTIFICATION -&gt; { // send push notification } Notification.EMAIL -&gt; { // send email notification } } } } It doesn’t seem to be a problem to execute, nor does it seem to violate OCP. However, what happens if I add a new Notification here? Assuming you need to add NotificationServiceSMS, it will be as follows enum class Notification { PUSH_NOTIFICATION, EMAIL, SMS } class NotificationService { fun sendNotification(notification: Notification) { when (notification) { Notification.PUSH_NOTIFICATION -&gt; { // send push notification } Notification.EMAIL -&gt; { // send email notification } Notification.SMS -&gt; { // send sms notification } } } } Maybe if you noticed it here, You must modify Notification Service each time you add a new value. Therefore, it can be seen as a violation of OCP. This can be resolved in the following ways: // Create an interface, not a class. interface Notification { fun sendNotification() } And create a class file for each Notification. // Inherit the Notification interface. class PushNotification : Notification { // Implement each function in a redefined form. override fun sendNotification() { // send push notification } } class EmailNotification : Notification { override fun sendNotification() { // send email notification } } Create a class file called NotificationService to integrate it. class NotificationService { fun sendNotification(notification: Notification) { notification.sendNotification() } } This will allow you to add new features by simply adding the file as follows without modifying the relevant Notification file. class SMSNotification : Notification { override fun sendNotification() { // send sms notification } } By using the interface in this way, you can use common parts and also use them redefine as needed. OCP is also very difficult to keep 100%, so it is important to always be conscious and use it properly when writing code. L - Liskov Substitution Principle(LSP) It is a part of the SOLID design that corresponds to L. To be defined as follows. If the datatype S is a subtype of datatype T, it must be possible to replace the object of datatype T with the object of datatype S without changing the properties of the necessary program. To put it more simply, When used in the same way, the child object should be able to use the ability of the parent object as it is. (I will explain this in detail in another post.) Moving on to the example, we’re going to create the following code. a service for collecting and sorting garbage interface Waste { fun process() } Waste interface를 상속받는 클래스 구현 class OrganicWaste : Waste { override fun process() { println(\"Processing Organic Waste\") } } class PlasticWaste : Waste { override fun process() { println(\"Processing Plastic Waste\") } } Implement a class using these two class WasteManagementService { fun processWaste(waste: Waste) { waste.process() } } Defining a function that uses it In the same way, processWaste of waste management service is called, but it satisfies the Liskoff substitution principle because it is doing the same process without affecting each other. fun main() { val wasteManagementService = WasteManagementService() var waste: Waste waste = OrganicWaste() wasteManagementService.processWaste(waste) // Output: Processing Organic Waste waste = PlasticWaste() wasteManagementService.processWaste(waste) // Output: Processing Plastic Waste } I - Interface Isolation Principle (ISP) It is a part of the SOLID design that corresponds to I. The definition is as follows. It should not be forced to implement unnecessary methods in a class that inherits unused interfaces. a bad example interface OnClickListener { fun onClick() fun onLongClick() } If the interface is defined in this way, both onClick() and onLongClick() should always be defined as follows class CustomUIComponent : OnClickListener { override fun onClick() { // handles onClick event. } // left empty as I don't want the [CustomUIComponent] to have long-click behavior. override fun onLongClick() { } } To solve this problem, we can just divide the interface. interface OnClickListener { fun onClick() } interface OnLongClickListener { fun onLongClick() } And only the necessary interfaces are inherited and used. class CustomUIComponent : OnClickListener { override fun onClick() { // handle single-click event } } D - Dependency Inversion Principle (DSP) It is a part of the SOLID design that corresponds to D. The definition is as follows. The project has independent modules. Submodules refer to (dependent) parent modules and A parent module cannot be referenced (dependent) on a child modules This is called the “Dependency Inversion Principle”. Simply put, “We rely only on elements that don’t change easily, but the parent module can’t rely on the child module.”Ida. Example code class ClassA { fun doSomething() { println(\"Doing something\") } } class ClassB { fun doIt() { // ClassB 는 ClassA가 반드시 있어야만 사용할 수 있다 = 즉, ClassA에 대해 의존성을 가진다 val classA = ClassA() classA.doSomething() } } Assume that you have a program that is dependent on // Notification to send an email class EmailNotification { fun sendNotification(message: String) { println(\"Sending email notification with message \\\"$message\\\"\") } } // The part where Notification is sent. class NotificationService { fun sendNotification(message: String) { // // Must rely on Email Notification in this part val emailNotification = EmailNotification() emailNotification.sendNotification(message) } } // Execution function fun main() { val notificationService = NotificationService() // Output: Sending email notification with message \"Happy Coding\" notificationService.sendNotification(\"Happy Coding\") } So far, there is no problem with dependencies, but there is a problem that other types of Notifications cannot be sent. You can remove dependencies in the following ways and have Notification Service send email as well as other types of Notification: Entire code interface Notification { fun sendNotification(message: String) } class EmailNotification : Notification { override fun sendNotification(message: String) { println(\"Sending email notification with message \\\"$message\\\"\") } } class SmsNotification : Notification { override fun sendNotification(message: String) { println(\"Sending sms notification with message \\\"$message\\\"\") } } fun main() { val message = \"Happy Coding\" val notificationService = NotificationService() var notification: Notification notification = EmailNotification() notificationService.notification = notification notificationService.sendNotification(message) // Output: Sending email notification with message \"Happy Coding\" notification = SmsNotification() notificationService.notification = notification notificationService.sendNotification(message) // Output: Sending sms notification with message \"Happy Coding\" } This independent dependence and OCP can be satisfied at the same time. Define a line in a SOLID design SRP: Each software module should have only one role. OCP: Software systems should be easy to change. Instead of changing the existing code, it should be designed to change the system behavior by adding new code. LSP: To build a software system with interchangeable parts, you must follow a contract to exchange those parts with each other. ISP: Software designers should avoid relying on unused items. DIP: Code implementing higher-level policies should not rely on lower-level details.",
    "tags": "android",
    "url": "/android/2022/12/19/android-solid/"
  },{
    "title": "Using DebugView with Firebase Analytics.",
    "text": "Using DebugView with Firebase Analytics Firebase Setting Dependency for Firebase DebugView Example code for Firebase DebugView Firebase DebugView Test Firebase Setting 1. Access Android Studio 2. Click [Tool] -&gt; [Firebase] at the top 3. Select [Analytics] from the menu -&gt; Get started with Google Analytics [Kotlin] 4. After that, you can follow the instructions for firebase. Dependency for Firebase DebugView implementation 'com.google.firebase:firebase-analytics:21.2.0' Example code for Firebase DebugView Code Story It is an app with a layout structure that has Main Activity and a fragment called First Fragment in it. MainActivity class MainActivity : AppCompatActivity() { private lateinit var binding: ActivityMainBinding private lateinit var analytics: FirebaseAnalytics override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) binding = ActivityMainBinding.inflate(layoutInflater) setContentView(binding.root) Timber.plant(MyTimber()) // init Analytics analytics = Firebase.analytics // send screen_view event analytics.logEvent(FirebaseAnalytics.Event.SCREEN_VIEW) { param(FirebaseAnalytics.Param.SCREEN_NAME, this@MainActivity.javaClass.simpleName) param(\"test\", \"test\") } } FirstFragment class FirstFragment : Fragment() { private var binding: FragmentFirstBinding by autoCleared() private lateinit var analytics: FirebaseAnalytics override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View { binding = FragmentFirstBinding.inflate(inflater, container, false) // init Analytics analytics = Firebase.analytics return binding.root } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) // send select_content event binding.analyticsButton.setOnClickListener { analytics.logEvent(FirebaseAnalytics.Event.SELECT_CONTENT) { param(FirebaseAnalytics.Param.SCREEN_NAME, this@FirstFragment.javaClass.simpleName) param(\"test\", \"test\") param(FirebaseAnalytics.Param.ITEM_NAME, \"test item name\"); } } } } completed Layout Firebase DebugView Test The Analytics test uses something called DebugView. There are tests using adb, but DebugView is intuitive and reliable. Using the code written above, you can obtain the following results Event to output MainActivity name when MainActivity is opened (screen_view) Send a click event when the SEND ANALYTICS button is pressed (select_content) Test DebugView with Analytics in Firebase Summary To set up Firebase Set up and define in Android Studio To define the dependencies required for Firebase To write code for use in Debug View Define events in Main Activity and Fragment Test DebugView (debug) When a specific screen is opened = screen_view When a specific click is made = select_content",
    "tags": "android",
    "url": "/android/2022/12/18/firebase-debugview/"
  }]};
